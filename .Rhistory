pkg.version <- installed.packages()[pkg, 'Version']
pkg.date <- installed.packages(fields="Date")[pkg, 'Date']
pkg.info <- paste(pkg, pkg.version, pkg.date)
rev <- system("bzr revno", intern=TRUE)
cpu <- system(paste("cat /proc/cpuinfo | grep 'model name' |",
"head -n 1 | cut -d':' -f2"), intern=TRUE)
ram <- system("cat /proc/meminfo | grep MemTotal: | awk '{print $2}'",
intern=TRUE)
ram <- paste0(round(as.integer(ram)/1e6, 1), "GB")
user <- Sys.getenv("LOGNAME")
node <- Sys.info()[["nodename"]]
user.node <- paste0(user, "@", node)
gcc.version <- system("g++ -v 2>&1 | grep 'gcc version' | cut -d' ' -f1-3",
intern=TRUE)
os <- system("lsb_release -d | cut -d: -f2 | sed 's/^[ \t]*//'", intern=TRUE)
## ----module, echo=FALSE, results="asis"----------------------------------
Module <- "BasicRO"
cat(paste0("\\newcommand{\\Module}{", Module, "}"))
set.seed(42)
## ----setup, child="mycourse.Rnw"-----------------------------------------
## ----setup_options, include=FALSE----------------------------------------
library(knitr)
library(xtable)
opts_chunk$set(cache=FALSE)
install_new<-function(mypkg){
if (mypkg %in% installed.packages()) cat("Package already installed")
else{cat("Package not found, so installing with dependencies... /n
Press CTRL C to abort.")
Sys.sleep(5)
install.packages(mypkg,repos="http://cran.wustl.edu/")
}
}
install_new('plyr')
install_new('lmtest')
install_new('ggplot2')
install_new('gridExtra')
install_new('stringr')
install_new('knitr')
install_new('quantreg')
install_new('zoo')
install_new('xtable')
install_new('lme4')
install_new('caret')
## @knitr , eval=FALSE,echo=TRUE,tidy=FALSE
install_new<-function(mypkg){
if (mypkg %in% installed.packages()) cat("Package already installed")
else{cat("Package not found, so installing with dependencies...\n
Press CTRL C to abort.")
Sys.sleep(5)
install.packages(mypkg,repos="http://cran.wustl.edu/")
}
}
install_new('plyr')
install_new('lmtest')
install_new('ggplot2')
install_new('gridExtra')
install_new('eeptools')
install_new('stringr')
install_new('knitr')
install_new('quantreg')
install_new('xtable')
install_new('lme4')
install_new('caret')
## @knitr eval=FALSE,echo=TRUE,tidy=FALSE
install.packages(c('plyr','lmtest','ggplot2','gridExtra','stringr',
'knitr','quantreg','xtable','lme4','eeptools','caret'),
repos="http://cran.wustl.edu/")
## @knitr eval=FALSE,echo=TRUE
library(lmtest)
example(gqtest)
## @knitr eval=TRUE,echo=FALSE
library(lmtest)
example(gqtest)
## @knitr echo=TRUE,eval=FALSE
library(ggplot2)
y<-rt(200,df=5)
qplot(sample=y,stat="qq")
## @knitr ,echo=TRUE,fig.width=9,fig.height=6
library(ggplot2)
y<-rt(200,df=5)
qplot(sample=y,stat="qq")
## @knitr ,echo=TRUE,eval=FALSE
options(repos=c(RStudio='http://rstudio.org/_packages', getOption('repos')))
install.packages('shiny')
## @knitr echo=TRUE,eval=FALSE
library(shiny)
install.packages(c("plyr", "lmtest", "ggplot2", "gridExtra",
## @knitr setup, include=FALSE
# set global chunk options
opts_chunk$set(fig.path='figure/slides-', cache.path='cache/slides-', cache=TRUE,
comment=NA)
# upload images automatically
#opts_knit$set(upload.fun = imgur_upload)
## @knitr echo=TRUE,error=TRUE
foo<-c(1,"b",5,7,0)
bar<-c(1,2,3,4,5)
foo+bar
## @knitr dataframeintro,echo=TRUE,results='hide'
data(mtcars)
mtcars
## @knitr dataframeintro2,echo=FALSE,results='markup'
mtcars[1:8,]
## @knitr computing,echo=TRUE,results='markup'
2+2 # add numbers
2*pi #multiply by a constant
7+runif(1,min=0,max=1) #add a random variable
4^4 # powers
sqrt(4^4) # functions
## @knitr arithmetic
2+2
2/2
2*2
2^2
2==2
23 %/% 2
23 %% 2
## @knitr
foo<-3
foo
## @knitr
1:10
# it increments by one
a<-100:120
a
## @knitr poundsigns,eval=FALSE,echo=TRUE,tidy=FALSE
# Something I want to keep from R
# Like my secret from the R engine
# Maybe intended for a human and not the computer
# Like: Look at this cool plot!
myplot(readSS,mathSS,data=df)
## @knitr
x<-5 #store a variable with <-
x    #print the variable
z<-3
ls() #list all variables
ls.str() #list and describe variables
rm(x)    # delete a variable
ls()
## @knitr
a<-3
A<-4
print(c(a,A))
## @knitr
A<-c(3,4)
print(A)
## @knitr language
a<-runif(100) # Generate 100 random numbers
b<-runif(100) # 100 more
c<-NULL       # Setup for loop (declare variables)
for(i in 1:100){  # Loop just like in Java or C
c[i]<-a[i]*b[i]
}
d<-a*b
identical(c,d) # Test equality
## @knitr eval=TRUE,echo=FALSE
load("data/smalldata.rda")
## @knitr
summary(df[,28:31]) #summary look at df object
summary(df$readSS) #summary of a single column
## @knitr graphics1,message=FALSE,dev='svg',fig.cap='Student Test Scores', fig.width=7.8, fig.height=4.5,tidy=FALSE,warning=FALSE
library(ggplot2) # Load graphics Package
library(eeptools)
qplot(readSS,mathSS,data=df,geom='point',alpha=I(0.3))+theme_dpi()+
opts(title='Test Score Relationship')+
geom_smooth()
## @knitr
length(unique(df$school))
length(unique(df$stuid))
uniqstu<-length(unique(df$stuid))
uniqstu
## @knitr vectorcomp
big<-c(9,12,15,25)
small<-c(9,3,4,2)
# Give us a nice vector of logical values
big>small
big=small
# Oops--don't do this, reassigns big to small
print(big)
print(small)
## @knitr brackets
big<-c(9,12,15,25)
big[big==small]
# Returns values where the logical vector is true
big[big>small]
big[big<small] # Returns an empty set
## @knitr specialoperand
big<-c(9,12,15,25)
small<-c(9,12,15,25,9,1,3)
big[small %in% big]
## @knitr operand2
big[big %in% small]
## @knitr vectorlogic
foo<-c('a',NA,4,9,8.7)
!is.na(foo) # Returns TRUE for non-NA
class(foo)
a<-foo[!is.na(foo)]
a
class(a)
## @knitr vectorlogic2
zap<-c(1,4,8,2,9,11)
zap[zap>2 | zap<8]
zap[zap>2 & zap<8]
## @knitr
is.numeric(A)
class(A)
print(A)
## @knitr
b<-c('one','two','three')
print(b)
is.numeric(b)
## @knitr
c<-c(TRUE,TRUE,TRUE,FALSE,FALSE,TRUE)
is.numeric(c)
is.character(c)
is.logical(c) # Results in a logical value
## @knitr class
class(A)
class(b)
class(c)
## @knitr fac
myfac<-factor(c("basic","proficient","advanced","minimal"))
class(myfac)
myfac # What order are the factors in?
## @knitr orderedfac
myfac_o<-ordered(myfac,levels=c("minimal","basic","proficient","advanced"))
myfac_o
summary(myfac_o)
## @knitr fac2
class(myfac_o)
unclass(myfac_o)
defac<-unclass(myfac_o)
defac
## @knitr fac2.1,eval=FALSE,echo=TRUE
# From the eeptools package
defac<-function(x){
x<-as.character(x)
x
}
## @knitr fac3
defac(myfac_o)
defac<-defac(myfac_o)
defac
## @knitr numericfac
myfac_o
as.numeric(myfac_o)
## @knitr numericfacwrong
myfac
as.numeric(myfac)
## @knitr dates
mydate<-as.Date("7/20/2012",format="%m/%d/%Y")
# Input is a character string and a parser
class(mydate) # this is date
weekdays(mydate) # what day of the week is it?
mydate+30 # Operate on dates
## @knitr moredates1
# We can parse other formats of dates
mydate2<-as.Date("8-5-1988",format="%d-%m-%Y")
mydate2
mydate-mydate2
# Can add and subtract two date objects
## @knitr moredates
as.numeric(mydate) # days since 1-1-1970
as.Date(56,origin="2013-4-29") # we can set our own origin
## @knitr linmod
b<-rnorm(5000)
c<-runif(5000)
a<-b+c
mymod<-lm(a~b)
class(mymod)
## @knitr vectors
print(1)
# The 1 in braces means this element is a vector of length 1
print("This tutorial is awesome")
# This is a vector of length 1 consisting of a single "string of characters"
## @knitr vectors2
print(LETTERS)
# This vector has 26 character elements
print(LETTERS[6])
# The sixth element of this vector has length 1
length(LETTERS[6])
# The length of that element is a number with length 1
## @knitr matrix
mymat<-matrix(1:36,nrow=6,ncol=6)
rownames(mymat)<-LETTERS[1:6]
colnames(mymat)<-LETTERS[7:12]
class(mymat)
## @knitr matrix2
rownames(mymat)
colnames(mymat)
mymat
## @knitr matrix3
dim(mymat) # We have 6 rows and 6 columns
myvec<-c(5,3,5,6,1,2)
length(myvec) # What happens when you do dim(myvec)?
newmat<-cbind(mymat,myvec)
newmat
## @knitr matrix4
foo.mat<-matrix(c(rnorm(100),runif(100),runif(100),rpois(100,2)),ncol=4)
head(foo.mat)
cor(foo.mat)
## @knitr matrixdance
mycorr<-cor(foo.mat)
class(mycorr)
mycorr2<-as.data.frame(mycorr)
class(mycorr2)
mycorr2
## @knitr array
myarray<-array(1:42,dim=c(7,3,2),dimnames=list(c("tiny","small",
"medium","medium-ish","large","big","huge"),
c("slow","moderate","fast"),c("boring","fun")))
class(myarray)
dim(myarray)
## @knitr array2
dimnames(myarray)
myarray
## @knitr lists
mylist<-list(vec=myvec,mat=mymat,arr=myarray,date=mydate)
class(mylist)
length(mylist)
names(mylist)
## @knitr listprint
str(mylist)
## @knitr lists2
mylist$vec
mylist[[2]][1,3]
## @knitr attr
attributes(mylist)
attributes(myarray)[1:2][2]
## @knitr dataframetypes,echo=TRUE,results='markup'
str(df[ ,25:32])
## @knitr session-info
print(sessionInfo(), locale=FALSE)
## ----module, echo=FALSE, results="asis"----------------------------------
Module <- "BayesO"
cat(paste0("\\newcommand{\\Module}{", Module, "}"))
## ----setup, child="mycourse.Rnw"-----------------------------------------
## ----setup_options, include=FALSE----------------------------------------
library(knitr)
library(xtable)
opts_chunk$set(cache=FALSE)
opts_chunk$set(out.width='0.8\\textwidth')
opts_chunk$set(fig.align='center')
opts_chunk$set(src.top=NULL)
opts_chunk$set(src.bot=NULL)
opts_chunk$set(out.lines=4)
opts_chunk$set(out.truncate=80)
opts_chunk$set(fig.path=sprintf("figures/%s/", Module))
opts_chunk$set(cache.path=sprintf("cache/%s/", Module))
opts_chunk$set(bib.file=paste0(Module, ".bib"))
# Leave code as I have formatted it.
opts_chunk$set(tidy=FALSE)
# Hooks
# Allow auto crop of base graphics plots when crop=TRUE.
knit_hooks$set(crop=hook_pdfcrop)
# Truncate long lines and long output
hook_output <- knit_hooks$get("output")
hook_source <- knit_hooks$get("source")
knit_hooks$set(output=function(x, options)
{
if (options$results != "asis")
{
# Split string into separate lines.
x <- unlist(stringr::str_split(x, "\n"))
# Trim to the number of lines specified.
if (!is.null(n <- options$out.lines))
{
if (length(x) > n)
{
# Truncate the output.
x <- c(head(x, n), "....\n")
}
}
# Truncate each line to length specified.
if (!is.null(m <- options$out.truncate))
{
len <- nchar(x)
x[len>m] <- paste0(substr(x[len>m], 0, m-3), "...")
}
# Paste lines back together.
x <- paste(x, collapse="\n")
# Replace ' = ' with '=' - my preference. Hopefully won't
# affect things inappropriately.
x <- gsub(" = ", "=", x)
}
hook_output(x, options)
},
source=function(x, options)
{
# Split string into separate lines.
x <- unlist(stringr::str_split(x, "\n"))
# Trim to the number of lines specified.
if (!is.null(n <- options$src.top))
{
if (length(x) > n)
{
# Truncate the output.
if (is.null(m <-options$src.bot)) m <- 0
x <- c(head(x, n+1), "\n....\n", tail(x, m+2))
}
}
# Paste lines back together.
x <- paste(x, collapse="\n")
hook_source(x, options)
})
# Optionally allow R Code chunks to be environments so we can refer to them.
knit_hooks$set(rcode=function(before, options, envir)
{
if (before)
sprintf('\\begin{rcode}\\label{%s}\\hfill{}', options$label)
else
'\\end{rcode}'
})
## ----load_packages, message=FALSE----------------------------------------
library(rattle)       # weather and normVarNames()
library(randomForest) # na.roughfix()
library(e1071)        # naiveBayes()
library(ROCR)         # prediction()
## ----common_intro, child='documentation.Rnw', eval=TRUE------------------
## ----help_library, eval=FALSE, tidy=FALSE--------------------------------
## ?read.csv
## ----help_package, eval=FALSE--------------------------------------------
## library(help=rattle)
## ----record_start_time, echo=FALSE---------------------------------------
start.time <- proc.time()
## ----generate_bib, echo=FALSE, message=FALSE, warning=FALSE--------------
# Write all packages in the current session to a bib file
if (is.null(opts_chunk$get("bib.file"))) opts_chunk$set(bib.file="Course.bib")
write_bib(sub("^.*/", "", grep("^/", searchpaths(), value=TRUE)),
file=opts_chunk$get("bib.file"))
system(paste("cat extra.bib >>", opts_chunk$get("bib.file")))
# Fix up specific issues.
# R-randomForest
system(paste("perl -pi -e 's|Fortran original by Leo Breiman",
"and Adele Cutler and R port by|Leo Breiman and",
"Adele Cutler and|'", opts_chunk$get("bib.file")))
# R-C50
system(paste("perl -pi -e 's|. C code for C5.0 by R. Quinlan|",
" and J. Ross Quinlan|'", opts_chunk$get("bib.file")))
# R-caret
system(paste("perl -pi -e 's|. Contributions from|",
" and|'", opts_chunk$get("bib.file")))
# Me
system(paste("perl -pi -e 's|Graham Williams|",
"Graham J Williams|'", opts_chunk$get("bib.file")))
## ----bayes_prepare_data_weather, message=FALSE---------------------------
library(rattle)		# Normalise names normVarNames() and weather dataset.
library(randomForest)	# Impute missing using na.roughfix().
dsname     <- "weather"
ds         <- get(dsname)
names(ds)  <- normVarNames(names(ds))
vars       <- names(ds)
target     <- "rain_tomorrow"
risk       <- "risk_mm"
id         <- c("date", "location")
ignore     <- union(id, if (exists("risk")) risk)
vars       <- setdiff(vars, ignore)
inputs     <- setdiff(vars, target)
numi       <- which(sapply(ds[inputs], is.numeric))
numc       <- names(numi)
cati       <- which(sapply(ds[inputs], is.factor))
catc       <- names(cati)
ds[numc]   <- na.roughfix(ds[numc]) # Impute missing values, roughly.
ds[target] <- as.factor(ds[[target]])	# Ensure the target is categoric.
nobs       <- nrow(ds)
form       <- formula(paste(target, "~ ."))
set.seed(42)
train      <- sample(nobs, 0.7*nobs)
test       <- setdiff(seq_len(nobs), train)
actual     <- ds[test, target]
risks      <- ds[test, risk]
## ----check_dataset, out.lines=5------------------------------------------
dim(ds)
names(ds)
head(ds)
tail(ds)
str(ds)
summary(ds)
## ----build_nb_model, out.lines=26----------------------------------------
library(e1071)
model      <- naiveBayes(form, data=ds[train, vars])
model
## ----evaluate_nb_model, message=FALSE, out.lines=NULL--------------------
classes    <- predict(model, ds[test, vars], type="class")
acc        <- sum(classes == actual, na.rm=TRUE)/length(actual)
err        <- sum(classes != actual, na.rm=TRUE)/length(actual)
predicted  <- predict(model, ds[test, vars], type="raw")[,2]
pred       <- prediction(predicted, ds[test, target])
ate        <- attr(performance(pred, "auc"), "y.values")[[1]]
riskchart(predicted, actual, risks)
round(table(actual, classes, dnn=c("Actual", "Predicted"))/length(actual), 2)
## ----common_outtro, child="finale.Rnw", eval=TRUE------------------------
## ----syinfo, child="sysinfo.Rnw", eval=TRUE------------------------------
## ----echo=FALSE, message=FALSE-------------------------------------------
require(Hmisc)
pkg <- "knitr"
pkg.version <- installed.packages()[pkg, 'Version']
pkg.date <- installed.packages(fields="Date")[pkg, 'Date']
pkg.info <- paste(pkg, pkg.version, pkg.date)
rev <- system("bzr revno", intern=TRUE)
cpu <- system(paste("cat /proc/cpuinfo | grep 'model name' |",
"head -n 1 | cut -d':' -f2"), intern=TRUE)
ram <- system("cat /proc/meminfo | grep MemTotal: | awk '{print $2}'",
intern=TRUE)
ram <- paste0(round(as.integer(ram)/1e6, 1), "GB")
user <- Sys.getenv("LOGNAME")
node <- Sys.info()[["nodename"]]
user.node <- paste0(user, "@", node)
gcc.version <- system("g++ -v 2>&1 | grep 'gcc version' | cut -d' ' -f1-3",
intern=TRUE)
os <- system("lsb_release -d | cut -d: -f2 | sed 's/^[ \t]*//'", intern=TRUE)
install.packages("foreign")
library("foreign", lib.loc="/usr/lib/R/library")
